---
title: "Notes on `new_grad_hess` function"
author: "William McCausland"
date: "16/07/2020"
output: pdf_document
---

Let the return values of `grad_hess_approx` be named as follows:

> `[g, H, V] = grad_hess_approx(theta, state, u)`.

Current return values of `new_grad_hess_approx`:

> `[g_y_th, EH_x_th, Vg_x_th] = new_grad_hess_approx(theta, state)`

Proposed return values of `new_grad_hess_approx` function:

> `[g_y_th, EH_x_th, Vg_x_th, mEH_x_th, mH_y_th] = new_grad_hess_approx(theta, state)`

where

1. `g_y_th`, $g_{y|\theta}(\theta) = E[g_{x|\theta}|\theta,y]$ in the paper. This corresponds to `g` in `grad_hess_approx` function.
1. `EH_x_th`, $E[H_{x|\theta}|\theta,y]$ in the paper.
1. `Vg_x_th`, $\mathrm{var}[g_{x|\theta}|\theta,y]$ in the paper. This corresponds to `V` in `grad_hess_approx`.
1. `H_y_th`, $H_{y|\theta}(\theta)$ in the paper. Equal to `Vg_x_th + EH_x_th`.
1. `mEH_x_th`, This roughly corresponds to `H` in `grad_hess_approx`. It is obtained by replacing certain elements of `EH_x_th`: change the element $(1,1)$ to $-n/2$ and the elements $(1,2)$, $(2,1)$, $(1,3)$ and $(3,1)$ to zero. The elements $(2,3)$ and $(3,2)$ are intentionally left alone, unlike `H` in `grad_hess_approx`.
1. `mH_y_th`. This is the recommended "averaged" Hessian matrix to use instead of `V + H`.
It is equal to `g_y_th + mEH_x_th`.

Some notes:

1. The code `new_grad_hess` should now be working better in every way than `grad_hess`. Perhaps the choice of Langevin parameters will need to be re-optimized before more effiency is obtained. Are results more efficient (i.e. numerically efficient)?
1. The code could probably be optimized so that it takes one half of its current running time and possibly less. Further speed could be obtained at the cost of a worse approximation. This code takes what fraction of a draw from $x|\theta,y$? What fraction of the time taken by `grad_hess_approx`?
1. It doesn't make sense to add an input to choose `mH_y_th` instead of `H_y_th`, at least not for computational efficiency reasons. The saved computation is negligible.
1. On the other hand, returning the $2\times 2$ sub-matrices and the $2\times 1$ subvector might save from $1/4$ to $1/3$ of the running time.
1. Everthing can be easily computed from the first three return values. This could be done in a matlab wrapper function, and we would be less likely to need to modify the matlab interface in the future.
1. There should probably be tildes in the Latex notation above. The values are approximate.
1. Unlike `grad_hess_approx`, `new_grad_hess_approx` does not have an input `u` for common random numbers.
1. I'm not at all committed to the order of outputs.
